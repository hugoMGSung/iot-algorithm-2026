// app07
// 1,000 이하의 소수를 나열 (버전 3)
// 이미 구한 소수만을 이용해 √n까지만 검사하여 연산을 줄이는 개선된 방식
// 또한 곱셈과 나눗셈의 실행 횟수를 직접 카운트하여 성능을 측정함

#include <stdio.h>

int main(void)
{
  int prime[500];     // 발견한 소수를 저장할 배열
  // 1000 이하의 소수는 168개이므로 500이면 충분

  int ptr = 0;        // 현재까지 저장된 소수의 개수
  // 동시에 배열의 다음 저장 위치 역할

  unsigned long counter = 0;
  // 곱셈(*)과 나눗셈(%)이 실행된 횟수를 저장
  // 성능 비교를 위한 변수

  // 2와 3은 미리 소수로 등록
  prime[ptr++] = 2;   // prime[0] = 2
  prime[ptr++] = 3;   // prime[1] = 3

  // 5부터 1000까지 검사
  // 2를 제외한 짝수는 모두 합성수이므로
  // 2씩 증가하여 홀수만 검사 (연산 절약)
  for (int n = 5; n <= 1000; n += 2) {

    int i;
    int flag = 0;   // 0이면 소수, 1이면 합성수

    // 이미 구한 소수(prime[i])로 나눠보면서 검사
    // prime[i] * prime[i] <= n 까지만 검사
    // (어떤 수가 합성수라면 √n 이하의 약수를 반드시 가짐)
    for (i = 1; counter++, prime[i] * prime[i] <= n; i++) {
      // ↑ 조건식이 실행될 때마다 counter 증가
      //   → prime[i] * prime[i] (곱셈) 연산 횟수 카운트 목적

      counter++;
      // ↓ 아래의 나눗셈 연산(%)을 세기 위해 증가

      if (n % prime[i] == 0) {
        // 이미 구한 소수로 나누어 떨어지면
        // n은 합성수
        flag = 1;
        break;  // 더 검사할 필요 없음
      }
    }

    // 마지막까지 나누어 떨어지지 않았다면 소수
    if (!flag)
      prime[ptr++] = n;  // 배열에 저장
  }

  // 저장된 소수 출력
  for (int i = 0; i < ptr; i++)
    printf("%d\n", prime[i]);

  // 전체 곱셈/나눗셈 실행 횟수 출력
  printf("곱셈과 나눗셈을 실행한 횟수: %lu\n", counter);

  return 0;
}